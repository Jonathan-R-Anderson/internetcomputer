===== ./filelist.txt =====

===== ./kernel/arch/paging.d =====
module arch.paging;

public import stl.vmm.paging;
public import stl.vmm.vmm;

version (X86_64) {
	public import arch.amd64.paging;
	import stl.address;

	private extern (C) ulong cpuRetCR3();
	void initKernelPaging() {
		import arch.amd64.paging : Paging;
		import stl.address : PhysAddress;

		PhysAddress pml4 = cpuRetCR3();
		_kernelPaging = Paging(pml4, false);
	}

	private __gshared Paging _kernelPaging = void;
	extern (C) Paging* getKernelPaging() @trusted {
		return &_kernelPaging;
	}

	extern (C) bool validAddress(VirtAddress vAddr) @trusted {
		return _kernelPaging.isValid(vAddr);
	}

	extern (C) VirtAddress mapSpecialAddress(PhysAddress pAddr, size_t size, bool readWrite = false, bool clear = false) @trusted {
		return _kernelPaging.mapSpecialAddress(pAddr, size, readWrite, clear);
	}

	extern (C) void unmapSpecialAddress(ref VirtAddress vAddr, size_t size) @trusted {
		_kernelPaging.unmapSpecialAddress(vAddr, size);
	}

	extern (C) bool mapAddress(VirtAddress vAddr, PhysAddress pAddr, VMPageFlags flags, bool clear = false) @trusted {
		return _kernelPaging.mapAddress(vAddr, pAddr, flags, clear);
	}

	extern (C) bool unmap(VirtAddress vAddr, bool freePage = false) @trusted {
		return _kernelPaging.unmap(vAddr, freePage);
	}
} else {
	static assert(0, "Paging is not implemented for the architecture!");
}

===== ./kernel/fs.d =====
// ===== kernel/fs.d =====
module kernel.fs;

struct File {
    string name;
    ubyte[] data;
}

File[string] files;

File* open(string path) {
    return path in files;
}

void writeFile(string path, ubyte[] data) {
    files[path] = File(name: path, data: data);
}

ubyte[] readFile(string path) {
    auto f = open(path);
    return f ? f.data : null;
}
===== ./kernel/fs/package.d =====
/**
 * The filesystem base types
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *    (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module fs;

public import fs.block;
public import fs.node;
public import fs.supernode;

===== ./kernel/fs/tarfs/block.d =====
/**
 * The filesystem base
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *    (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module fs.tarfs.block;

import fs.tarfs;

import stl.address;
import stl.io.log;
import stl.vmm.heap;

@safe struct TarFSBlockDevice {
	import stl.address : VirtMemoryRange;

	FSBlockDevice base;
	alias base this;

	VirtMemoryRange data;

	this(VirtMemoryRange range) {
		data = range;
		with (base) {
			readBlock = &this.readBlock;
			writeBlock = &this.writeBlock;
			getBlockCount = &this.getBlockCount;
		}
	}

	void readBlock(FSBlockDevice.BlockID idx, ref FSBlock block) {
		Log.error("TarFSBlockDevice.readBlock: ", idx);
		block = FSBlock();
	}

	void writeBlock(FSBlockDevice.BlockID idx, const ref FSBlock block) {
		Log.error("TarFSBlockDevice.writeBlock: ", idx);
	}

	size_t getBlockCount() {
		Log.error("TarFSBlockDevice.getBlockCount: ");
		return 0;
	}
}

===== ./kernel/process.d =====
module system.kernel.process;

enum TaskStatus { Runnable, Exited }

struct Process {
    size_t pid;
    TaskStatus status;
    size_t exitCode;
}

// Temporary global for proof of concept
__gshared Process currentProc = Process(pid: 1, status: TaskStatus.Runnable);

Process* currentProcess() {
    return &currentProc;
}

===== ./kernel/syscall/action/exit.d =====
module syscall.action.exit;

import syscall;
import task.scheduler;
import task.task;       // Assuming this defines Task structure
import memory.manager;  // If needed to deallocate resources

@Syscall(0)
@SyscallArgument!(size_t)
size_t exit(size_t returnValue) {
    auto current = Scheduler.currentTask();

    // Mark the task as exited (assuming status/exitCode exist)
    current.exitCode = returnValue;
    current.status = TaskStatus.Exited;

    // Remove from scheduler queue or mark as inactive
    Scheduler.terminateCurrent();

    // Prevent returning
    while (true)
        Scheduler.yield();

    assert(0, "Scheduler.terminateCurrent() failed to halt the process.");
    return 0;
}

===== ./kernel/syscall/action/fork.d =====
module syscall.action.fork;

import syscall;
import task.scheduler;

@Syscall(3) size_t fork() {
	return Scheduler.fork();
}

===== ./kernel/syscall/action/package.d =====
module syscall.action;
/*
private alias tuple(T...) = T;
private template ImportSyscall(T...) {

	string ImportSyscall;

	static foreach (t; T) {
		ImportSyscall ~= "public import syscall.action." ~ t ~ ";\n";
	}

ImportSyscall ~= "alias Syscalls = tuple!(";
	static foreach (t; T) {

			foreach (func; __traits(allMembers, mixin("syscall.action."~t))
				foreach (attr; __traits(getAttributes, mixin(func)))
					static if (is(typeof(attr) == Syscall)) {
						ImportSyscall~= "func"
					}

	}
}

mixin(ImportSyscall!());*/

public import syscall.action.exit;
public import syscall.action.yield;
public import syscall.action.write;
public import syscall.action.fork;

enum string[] SyscallModules = ["exit", "yield", "write", "fork"];

===== ./kernel/syscall/action/process.d =====
// src/kernel/syscall/getpid.d
module syscall.action.getpid;

import syscall;
import kernel.process;

@Syscall(5) // syscall number
size_t getpid() {
    return currentProcess().pid;
}

===== ./kernel/syscall/action/write.d =====
module syscall.action.write;

import syscall;

@Syscall(2) @SyscallArgument!(size_t) @SyscallArgument!(string) size_t write(size_t fileID, string msg) {
	import stl.io.vga : VGA;
	import stl.io.log : Log;

	import task.scheduler;
	import task.thread;

	VMThread* thread = Scheduler.getCurrentThread();

	VGA.write(msg);

	if (thread)
		Log.info("[", fileID, "][pid:", thread.pid, "][name:", thread.name, "] ", msg[0 .. (msg[$ - 1] == '\n') ? $ - 1 : $]);
	else
		Log.info("[", fileID, "] ", msg[0 .. (msg[$ - 1] == '\n') ? $ - 1 : $]);
	return msg.length;
}

===== ./kernel/syscall/action/yield.d =====
module syscall.action.yield;

import syscall;

import stl.io.log;
import task.scheduler;
import task.thread;

@Syscall(1) size_t yield() {
	Scheduler.yield();
	return 0;
}

===== ./kernel/syscall/getpid.d =====
module system.kernel.syscall.getpid;

import syscall;                  // existing syscall framework in repo
import system.kernel.process;

@Syscall(4)  // Pick an unused number
size_t getpid() {
    return currentProcess().pid;
}

===== ./kernel/syscall/open.d =====
// ===== kernel/syscall/open.d =====
module kernel.syscall.open;

import kernel.fs;

size_t open(size_t ptr, size_t unused) {
    string path = cast(string) ptr;
    auto file = open(path);
    return cast(size_t) file;
}
===== ./kernel/syscall/syscall.d =====
// ===== kernel/syscall.d =====
module kernel.syscall;

alias SyscallHandler = size_t function(size_t, size_t);

SyscallHandler[6] syscallTable;

void registerSyscalls() {
    import kernel.syscall.exit;
    import kernel.syscall.getpid;
    import kernel.syscall.fork;
    import kernel.syscall.write;
    import kernel.syscall.open;

    syscallTable[0] = &exit;
    syscallTable[1] = &getpid;
    syscallTable[2] = &fork;
    syscallTable[3] = &write;
    syscallTable[4] = &open;
}

size_t syscallDispatcher(size_t num, size_t arg1, size_t arg2) {
    if (auto f = num in syscallTable)
        return (*f)(arg1, arg2);
    return size_t.max; // invalid syscall
}

===== ./kernel/userspace/init.d =====
// ===== userspace/init.d =====
module userspace.init;

import userspace.shell;

int main(string[] args) {
    write(1, "Init started\n");
    shell();
    return 0;
}
===== ./kernel/userspace/programs/cat.d =====
// ===== userspace/programs/cat.d =====
module userspace.programs.cat;

import userspace.syscall_wrappers;

void cat(string path) {
    write(1, "contents of " ~ path ~ "\n");
}

===== ./kernel/userspace/programs/echo.d =====

// ===== userspace/programs/echo.d =====
module userspace.programs.echo;

import userspace.syscall_wrappers;

void echo(string msg) {
    write(1, msg ~ "\n");
}

===== ./kernel/userspace/programs/ls.d =====
// ===== userspace/programs/ls.d =====
module userspace.programs.ls;

import userspace.syscall_wrappers;

void ls() {
    write(1, "file1\nfile2\n");
}

===== ./kernel/userspace/shell.d =====
// ===== userspace/shell.d =====
module userspace.shell;

import userspace.syscall_wrappers;

void shell() {
    while (true) {
        write(1, "> ");
        string input;
        readln(input);
        if (input == "exit")
            break;
        else if (input == "ls")
            ls();
        else if (input.length)
            write(1, "Unknown command\n");
    }
}

void ls() {
    write(1, "file1\nfile2\n");
}

===== ./kernel/userspace/syscall_wrappers.d =====
// ===== userspace/syscall_wrappers.d =====
module userspace.syscall_wrappers;

extern(C) size_t syscall(size_t num, size_t arg1, size_t arg2);

size_t write(size_t fd, string msg) {
    return syscall(3, fd, cast(size_t) msg.ptr);
}

size_t fork() {
    return syscall(2, 0, 0);
}

size_t exit(size_t code) {
    return syscall(0, code, 0);
}

size_t getpid() {
    return syscall(1, 0, 0);
}
===== ./kernel/vfs.d =====
// ===== kernel/vfs.d =====
module kernel.vfs;

import kernel.fs;

struct MountPoint {
    string path;
    File[string]* fs;
}

MountPoint[] mounts;

void mount(string path, File[string]* fs) {
    mounts ~= MountPoint(path: path, fs: fs);
}

File* vfsOpen(string fullPath) {
    foreach (m; mounts) {
        if (fullPath.startsWith(m.path)) {
            string rel = fullPath[m.path.length .. $];
            return (*m.fs)[rel.ptr];
        }
    }
    return null;
}

===== ./loader-api/powerd/api/memory.d =====
/**
 * This handles the API interface for the memory data structures.
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module powerd.api.memory;

import stl.address;

/// The PowerD memory information container
@safe struct PowerDMemory {
	ulong maxFrames; ///
	ulong usedFrames; ///
	ulong[] bitmaps; ///
	ulong currentBitmapIdx; ///
}

===== ./loader/arch/amd64/aml.d =====
/**
 * A AML helper module
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module arch.amd64.aml;

/// Opcodes that exist in AML
enum AMLOpcodes : ubyte {
	nameOP = 0x08, ///
	bytePrefix = 0x0A, ///
	packageOP = 0x12 ///
}

===== ./loader/arch/amd64/pic.d =====
/**
 * A $(I 8259 Programmable Interrupt Controller), also called PIC, helper module
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module arch.amd64.pic;

///
@safe static struct PIC {
public static:
	///
	@property ref bool enabled() @trusted {
		__gshared bool isEnabled = true;
		return isEnabled;
	}

	///
	void disable() {
		import stl.arch.amd64.ioport : outp;

		enum masterPort = 0x21;
		enum slavePort = 0xA1;

		outp!ubyte(masterPort, 0xFF);
		outp!ubyte(slavePort, 0xFF);
		enabled = false;
	}
}

===== ./loader/arch/amd64/pit.d =====
/**
 * A module for interfacing with the $(I Programmable Interval Timer), also called PIT.
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module arch.amd64.pit;

import stl.register;

@safe static struct PIT {
public static:
	void init(uint hz = 1000) @trusted {
		import stl.arch.amd64.idt : IDT, irq;
		import stl.arch.amd64.ioport : outp;

		IDT.register(irq(0), &_onTick);
		_hz = hz;
		uint divisor = 1193180 / hz;
		outp!ubyte(0x43, 0x36);

		ubyte l = cast(ubyte)(divisor & 0xFF);
		ubyte h = cast(ubyte)((divisor >> 8) & 0xFF);

		outp!ubyte(0x40, l);
		outp!ubyte(0x40, h);
	}

	void earlySleep(size_t amount) @trusted {
		size_t endAt = _counter + amount;

		while (_counter < endAt) {
			asm pure @trusted nothrow @nogc {
				hlt;
			}
		}
	}

private static:
	__gshared bool _enabled;
	__gshared uint _hz;
	__gshared size_t _counter;

	void _onTick(Registers* regs) @trusted {
		_counter++;
	}
}

===== ./loader/utils.d =====
/**
 * Some helper functions that are needed in object.d.
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module utils;

///
int memcmp(const(void)* src1, const(void)* src2, size_t size) @trusted @nogc pure nothrow {
	const(ubyte)* p1 = cast(const(ubyte)*)src1;
	const(ubyte)* p2 = cast(const(ubyte)*)src2;
	while (size--) {
		if (*p1 < *p2)
			return -1;
		else if (*p1 > *p2)
			return 1;

		p1++;
		p2++;
	}
	return 0;
}

///
size_t memcpy(void* dest, const(void)* src, size_t size) @trusted @nogc pure nothrow {
	ubyte* d = cast(ubyte*)dest;
	const(ubyte)* s = cast(const(ubyte)*)src;
	size_t n = size;
	while (n--)
		*(d++) = *(s++);

	return size;
}

///
size_t strlen(const(char)* str) @trusted @nogc pure nothrow {
	size_t count;
	while (*str)
		count++;
	return count;
}

===== ./stl/invariant.d =====
/**
 * D internal module that is needed to be able to compile.
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */

// This file should not have a 'module' line and should only contain this function
void _d_invariant(void* o) {}

===== ./stl/stl/arch/amd64/cpu.d =====
module stl.arch.amd64.cpu;

size_t getCoreID() @safe {
	import stl.arch.amd64.lapic : LAPIC;
	return LAPIC.getCurrentID();
}

===== ./stl/stl/arch/amd64/tsc.d =====
/**
 *
 *
 * Copyright: © 2019, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module stl.arch.amd64.tsc;

@safe static struct TSC {
public static:
	void sleep(uint msec) @trusted {
		size_t oldTime = void;
		asm {
			rdtsc;
			mov oldTime, RAX;
		}
		while (true) {
			size_t newTime = void;
			asm {
				rdtsc;
				mov newTime, RAX;
			}
			if (oldTime + (msec * frequency) / 1000 < newTime)
				break;
		}
	}

	@property ref size_t frequency() @trusted {
		return _frequency;
	}

private static:
	__gshared size_t _frequency;

}

===== ./stl/stl/io/e9.d =====
module stl.io.e9;

/// The E9 debug output port
@safe struct E9 {
public static:
	///
	void write(ubyte d) {
		import stl.arch.amd64.ioport : outp;

		outp!ubyte(0xE9, d);
	}

	///
	void write(T : ubyte)(T[] data) {
		foreach (d; data)
			write(d);
	}

	///
	void write(Args...)(Args args) {
		foreach (arg; args)
			write(arg);
	}
}

===== ./stl/stl/number.d =====
/**
 * A couple of math functions.
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module stl.number;

///
T abs(T)(T i) {
	if (i < 0)
		return -i;
	return i;
}

// https://github.com/Vild/PowerNex/commit/9db5276c34a11d86213fe7b19878762a9461f615#commitcomment-22324396
///
ulong log2(ulong value) {
	ulong result;
	asm pure @trusted nothrow @nogc {
		bsr RAX, value;
		mov result, RAX;
	}

	//2 ^ result == value means value is a power of 2 and we dont need to round up
	if (1 << result != value)
		result++;

	return result;
}

///
T min(T)(T a, T b) {
	return a < b ? a : b;
}

///
T max(T)(T a, T b) {
	return a > b ? a : b;
}

===== ./stl/stl/spinlock.d =====
/**
 * A spinlock implementation.
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *  (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module stl.spinlock;

private extern extern (C) void mutexSpinlock(uint* value) nothrow @nogc @trusted;
private extern extern (C) ulong mutexTrylock(uint* value) nothrow @nogc @trusted;
private extern extern (C) void mutexUnlock(uint* value) nothrow @nogc @trusted;

///
@safe align(8) struct SpinLock {
public:
	///
	void lock() {
		import stl.io.vga : VGA;

		mutexSpinlock(&_value);
		assert(_value);
	}

	///
	bool tryLock() {
		return !!mutexTrylock(&_value);
	}

	///
	void unlock() {
		assert(_value);
		mutexUnlock(&_value);
	}

	///
	@property bool isLocked() {
		return !!_value;
	}

private:
	align(8) uint _value;
}

===== ./stl/stl/vtable.d =====
/**
 * Helper function for managing VTables
 *
 * Copyright: © 2015-2017, Dan Printzell
 * License: $(LINK2 https://www.mozilla.org/en-US/MPL/2.0/, Mozilla Public License Version 2.0)
 *    (See accompanying file LICENSE)
 * Authors: $(LINK2 https://vild.io/, Dan Printzell)
 */
module stl.vtable;

/**
 * VTablePtr verifies that the $(PARAM TInput) function uses the same prototype
 * as $(PARAM Target), and that the first argument extends the first argument of $(PARAM Target).
 * Params:
 *      Target - The function pointer type to be cast to
 *      TInput - The function pointer type that will be cast
 *      Input  - The function pointer of type TInput
 */
pragma(inline, true) Target VTablePtr(Target, TInput)(TInput Input) {
	import stl.trait : parameters, Unqual;

	alias T = parameters!Target[0];
	alias I = parameters!TInput[0];

	static foreach (name; __traits(allMembers, I)) {
		static if (is(typeof(__traits(getMember, I, name)) == T))
			static assert(__traits(getMember, I, name).offsetof == 0, T.stringof ~ " needs to be the first member in " ~ I.stringof);
	}
	static assert(is(parameters!Target[1 .. $] == parameters!TInput[1 .. $]));
	return cast(Target)Input;
}

